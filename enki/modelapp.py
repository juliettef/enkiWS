from google.appengine.ext import ndb
from google.appengine.ext.ndb import model

from enki.modelrestapidatastore import EnkiModelRestAPIDataStore
from enki.modelrestapitokenverify import EnkiModelRestAPITokenVerify


class EnkiModelApp( model.Model ):

	#=== MODEL ====================================================================

	user_id = model.IntegerProperty()
	name = model.StringProperty()
	secret = model.StringProperty()
	time_created = model.DateTimeProperty( auto_now_add = True )

	#=== CONSTANTS ================================================================

	APP_MAX = 10    # maximum number of apps per user
	APP_MAX_NAME_LENGTH = 32

	#=== QUERIES ==================================================================

	@classmethod
	def exist_by_name( cls, name ):
		count = cls.query( cls.name == name ).count( 1 )
		return count > 0

	@classmethod
	def count_by_user_id( cls, user_id ):
		return cls.query( cls.user_id == user_id ).count()

	@classmethod
	def fetch_by_user_id( cls, user_id ):
		list = cls.query( cls.user_id == user_id ).order( cls.time_created ).fetch()
		return list

	#=== UTILITIES ================================================================

	@classmethod
	def exist_by_app_id_app_secret( cls, app_id, app_secret ):
		item = ndb.Key( cls, int( app_id )).get()
		if item and item.secret == app_secret:
			return True
		return False

	@classmethod
	def check_secret( cls, user_id, auth_token, app_secret ):
		if EnkiModelRestAPITokenVerify.exist_by_user_id_token_app_secret(user_id, auth_token, app_secret):
			# the user verify token contains the same secret as was sent in the request
			return True
		else:
			# retrieve the app_id from the verify token and check if the corresponding registered app has a new secret
			token_verify = EnkiModelRestAPITokenVerify.get_by_user_id_token(user_id, auth_token)
			if token_verify:
				app = cls.get_by_id(int(token_verify.app_id))
				if app and app.secret == app_secret:
					# update the user's verify token app_secret
					token_verify.app_secret = app.secret
					token_verify.put()
					return True
		return False

	@classmethod
	def apps_list( cls, user_id ):
		list = [ ]
		apps = cls.fetch_by_user_id(user_id)
		for app in apps:
			list.append([ app.name, str(app.key.id()), app.secret, app.time_created ])
		return list

	@classmethod
	def user_data_list( cls, user_id ):
		list = [ ]
		data_stores = EnkiModelRestAPIDataStore.fetch_by_user_id(user_id)
		for data_store in data_stores:
			app_name = ''
			app = cls.get_by_id(int(data_store.app_id))
			if app:
				app_name = app.name
			list.append(
				[ data_store.app_id, app_name, data_store.data_type, data_store.data_id, data_store.data_payload,
				  data_store.read_access, data_store.time_expires ])
		return list

	@classmethod
	def user_apps_list( cls, data_list ):    # data_list generated by user_data_list
		list_id = [ ]
		list_id_name = [ ]
		for item in data_list:
			if item[ 0 ] not in list_id:
				list_id.append(item[ 0 ])
				list_id_name.append([ item[ 0 ], item[ 1 ] ])
		return list_id_name
